#!/usr/bin/env python3
"""
Cobblemon Pack Error Checker (v2.0)
Validates all files in your Cobblemon pack for common errors
NOW WITH: Filename validation, bone matching, poser validation, and more!
"""

import json
import os
from pathlib import Path
from typing import Dict, List, Tuple


class CobblemonPackChecker:
    """Checks Cobblemon packs for errors"""
    
    VALID_TYPES = [
        "normal", "fire", "water", "electric", "grass", "ice", "fighting",
        "poison", "ground", "flying", "psychic", "bug", "rock", "ghost",
        "dragon", "dark", "steel", "fairy"
    ]
    
    REQUIRED_ANIMATIONS = [
        "ground_idle", "ground_walk", "battle_idle"
    ]
    
    OPTIONAL_ANIMATIONS = [
        "sleep", "faint", "cry", "air_idle", "air_fly", "water_idle", "water_swim"
    ]
    
    # Common Cobblemon moves (not exhaustive, but catches most typos)
    COMMON_MOVES = {
        "tackle", "scratch", "pound", "ember", "water_gun", "watergun", "vine_whip", "vinewhip", 
        "thundershock", "quick_attack", "quickattack", "bite", "flame_charge", "flamecharge",
        "bubble_beam", "bubblebeam", "razor_leaf", "razorleaf", "thunderbolt", "fire_blast", "fireblast",
        "hydro_pump", "hydropump", "solar_beam", "solarbeam", "thunder", "earthquake", "surf",
        "psychic", "shadow_ball", "shadowball", "ice_beam", "icebeam", "flamethrower", 
        "dragon_pulse", "dragonpulse", "dragon_breath", "dragonbreath", "dragon_claw", "dragonclaw",
        "hyper_beam", "hyperbeam", "giga_impact", "gigaimpact", "draco_meteor", "dracometeor",
        "outrage", "play_rough", "playrough", "moonblast", "dazzling_gleam", "dazzlinggleam",
        "body_slam", "bodyslam", "take_down", "takedown", "double_edge", "doubleedge", "slash",
        "iron_tail", "irontail", "iron_head", "ironhead", "iron_defense", "irondefense",
        "aerial_ace", "aerialace", "air_slash", "airslash", "air_cutter", "aircutter",
        "hurricane", "brave_bird", "bravebird", "stone_edge", "stoneedge", "rock_slide", "rockslide",
        "bulldoze", "mud_shot", "mudshot", "mud_slap", "mudslap", "earth_power", "earthpower",
        "drill_run", "drillrun", "poison_jab", "poisonjab", "sludge_bomb", "sludgebomb",
        "gunk_shot", "gunkshot", "cross_poison", "crosspoison", "venoshock", "toxic",
        "lava_plume", "lavaplume", "eruption", "overheat", "heat_wave", "heatwave",
        "scald", "aqua_tail", "aquatail", "waterfall", "crunch", "dark_pulse", "darkpulse",
        "night_slash", "nightslash", "sucker_punch", "suckerpunch", "foul_play", "foulplay",
        "flash_cannon", "flashcannon", "steel_wing", "steelwing", "meteor_mash", "meteormash",
        "metal_burst", "metalburst", "play_rough", "playrough", "charm", "baby_doll_eyes", "babydolleyes",
        "helping_hand", "helpinghand", "protect", "detect", "rest", "sleep_talk", "sleeptalk",
        "roar", "growl", "tail_whip", "tailwhip", "sand_attack", "sandattack", "swift",
        "confusion", "gust", "psybeam", "future_sight", "futuresight", "wish", "refresh",
        "cotton_guard", "cottonguard", "sweet_scent", "sweetscent", "last_resort", "lastresort",
        "trump_card", "trumpcard"
    }
    
    # Common Cobblemon abilities (not exhaustive, but catches most typos)
    COMMON_ABILITIES = {
        "overgrow", "blaze", "torrent", "swarm", "keen_eye", "tangled_feet", "big_pecks",
        "guts", "hustle", "inner_focus", "intimidate", "hyper_cutter", "sand_veil", "sand_rush",
        "static", "lightning_rod", "volt_absorb", "motor_drive", "competitive", "defiant",
        "levitate", "synchronize", "magic_guard", "magic_bounce", "filter", "solid_rock",
        "storm_drain", "water_absorb", "dry_skin", "hydration", "rain_dish", "swift_swim",
        "chlorophyll", "leaf_guard", "solar_power", "flash_fire", "drought", "flame_body",
        "white_smoke", "pure_power", "huge_power", "wonder_guard", "air_lock", "cloud_nine",
        "compound_eyes", "tinted_lens", "insomnia", "vital_spirit", "immunity", "limber",
        "oblivious", "own_tempo", "adaptability", "skill_link", "technician", "iron_fist",
        "sheer_force", "serene_grace", "super_luck", "sniper", "stall", "slow_start",
        "truant", "normalize", "wonder_skin", "unaware", "simple", "contrary", "defeatist",
        "cursed_body", "weak_armor", "heavy_metal", "light_metal", "multiscale", "toxic_boost",
        "flare_boost", "harvest", "telepathy", "moody", "overcoat", "poison_heal", "regenerator",
        "naturalcure", "arenatrap", "pixilate", "refrigerate", "aerilate", "galvanize"
    }
    
    # Valid egg groups
    VALID_EGG_GROUPS = {
        "monster", "water1", "bug", "flying", "field", "fairy", "grass", "humanlike",
        "water3", "mineral", "amorphous", "water2", "ditto", "dragon", "undiscovered"
    }
    
    def __init__(self, pack_path: str = None):
        if pack_path is None:
            pack_path = str(Path.home() / "Downloads" / "Mod-ResourceAndBehavior-Packs")
        
        self.pack_path = Path(pack_path)
        self.errors = []
        self.warnings = []
        self.info = []
        self.dex_numbers = {}  # Track dex numbers to find duplicates
        self.model_bones = {}  # Cache model bones for validation
        
    def check_all(self):
        """Run all checks"""
        print(f"\n{'='*70}")
        print("üîç COBBLEMON PACK ERROR CHECKER v2.0")
        print(f"{'='*70}")
        print("‚ú® NEW in v2.0:")
        print("   ‚Ä¢ Filename validation (dots vs underscores)")
        print("   ‚Ä¢ Poser 'head' field null bug detection")
        print("   ‚Ä¢ Animation-Model bone matching")
        print("   ‚Ä¢ Case sensitivity checks")
        print("   ‚Ä¢ PNG format validation")
        print("   ‚Ä¢ Move list validation")
        print(f"{'='*70}\n")
        print(f"üìÅ Checking pack: {self.pack_path}\n")
        
        # Check pack structure
        self.check_pack_structure()
        
        # Find all Pokemon
        pokemon_list = self.find_all_pokemon()
        
        if not pokemon_list:
            self.errors.append("No Pok√©mon found in pack!")
            self.print_results()
            return
        
        print(f"Found {len(pokemon_list)} Pok√©mon to check...\n")
        
        # Check each Pokemon
        for pokemon_name in pokemon_list:
            self.check_pokemon(pokemon_name)
        
        # Print results
        self.print_results()
    
    def check_pack_structure(self):
        """Check basic pack structure"""
        print("üì¶ Checking pack structure...")
        
        # Check resource pack
        resource_pack = self.pack_path / "resource_pack"
        if not resource_pack.exists():
            self.errors.append("Missing resource_pack folder!")
        else:
            self.info.append("‚úì resource_pack folder exists")
        
        # Check behavior pack
        behavior_pack = self.pack_path / "behavior_pack"
        if not behavior_pack.exists():
            self.errors.append("Missing behavior_pack folder!")
        else:
            self.info.append("‚úì behavior_pack folder exists")
        
        print()
    
    def find_all_pokemon(self) -> List[str]:
        """Find all Pokemon in the pack"""
        pokemon = set()
        
        # Check species files
        species_dir = self.pack_path / "behavior_pack" / "data" / "cobblemon" / "species" / "custom"
        if species_dir.exists():
            for file in species_dir.glob("*.json"):
                pokemon.add(file.stem)
        
        return sorted(list(pokemon))
    
    def check_pokemon(self, pokemon_name: str):
        """Check all files for a specific Pokemon"""
        print(f"üîç Checking {pokemon_name.upper()}...")
        
        errors_found = False
        
        # CRITICAL: Check for case sensitivity issues
        if pokemon_name != pokemon_name.lower():
            self.errors.append(f"{pokemon_name}: ‚ùå CRITICAL! Pokemon name has uppercase letters")
            self.errors.append(f"  All Pokemon names must be lowercase: '{pokemon_name.lower()}'")
            errors_found = True
        
        # CRITICAL: Check for special characters
        import re
        if not re.match(r'^[a-z0-9_]+$', pokemon_name):
            self.errors.append(f"{pokemon_name}: ‚ùå CRITICAL! Pokemon name contains invalid characters")
            self.errors.append(f"  Only lowercase letters, numbers, and underscores allowed")
            errors_found = True
        
        # Check species file
        if not self.check_species_file(pokemon_name):
            errors_found = True
        
        # Check model file
        if not self.check_model_file(pokemon_name):
            errors_found = True
        
        # Check animation file
        if not self.check_animation_file(pokemon_name):
            errors_found = True
        
        # Check texture files
        if not self.check_texture_files(pokemon_name):
            errors_found = True
        
        # Check poser file
        if not self.check_poser_file(pokemon_name):
            errors_found = True
        
        # Check resolver file
        if not self.check_resolver_file(pokemon_name):
            errors_found = True
        
        # Check spawn file
        if not self.check_spawn_file(pokemon_name):
            errors_found = True
        
        if not errors_found:
            print(f"   ‚úÖ All checks passed!\n")
        else:
            print(f"   ‚ö†Ô∏è  Issues found (see below)\n")
    
    def check_species_file(self, pokemon_name: str) -> bool:
        """Check species JSON file"""
        species_file = self.pack_path / "behavior_pack" / "data" / "cobblemon" / "species" / "custom" / f"{pokemon_name}.json"
        
        if not species_file.exists():
            self.errors.append(f"{pokemon_name}: Missing species file: {species_file}")
            return False
        
        try:
            with open(species_file, 'r') as f:
                data = json.load(f)
            
            # Check required fields
            required_fields = ["name", "nationalPokedexNumber", "primaryType", "baseStats"]
            for field in required_fields:
                if field not in data:
                    self.errors.append(f"{pokemon_name}: Missing required field '{field}' in species file")
            
            # Check for duplicate dex numbers
            if "nationalPokedexNumber" in data:
                dex_num = data["nationalPokedexNumber"]
                if dex_num in self.dex_numbers:
                    self.errors.append(f"{pokemon_name}: ‚ùå DUPLICATE DEX NUMBER #{dex_num}!")
                    self.errors.append(f"  Already used by: {self.dex_numbers[dex_num]}")
                else:
                    self.dex_numbers[dex_num] = pokemon_name
            
            # Check types
            if "primaryType" in data:
                ptype = data["primaryType"]
                if ptype is None:
                    self.errors.append(f"{pokemon_name}: primaryType is null!")
                else:
                    ptype = ptype.lower()
                    if ptype not in self.VALID_TYPES:
                        self.warnings.append(f"{pokemon_name}: Invalid primary type '{ptype}'")
            
            if "secondaryType" in data:
                stype = data["secondaryType"]
                if stype is None:
                    # Secondary type can be null (single-type Pokemon)
                    pass
                else:
                    stype = stype.lower()
                    if stype not in self.VALID_TYPES:
                        self.warnings.append(f"{pokemon_name}: Invalid secondary type '{stype}'")
            
            # Check base stats
            if "baseStats" in data:
                stats = data["baseStats"]
                required_stats = ["hp", "attack", "defence", "special_attack", "special_defence", "speed"]
                for stat in required_stats:
                    if stat not in stats:
                        self.errors.append(f"{pokemon_name}: Missing base stat '{stat}'")
                    else:
                        stat_value = stats[stat]
                        if not isinstance(stat_value, (int, float)):
                            self.errors.append(f"{pokemon_name}: Stat '{stat}' must be a number, got: {type(stat_value).__name__}")
                        elif stat_value < 1:
                            self.errors.append(f"{pokemon_name}: Stat '{stat}' is {stat_value} (must be at least 1)")
                        elif stat_value > 255:
                            self.warnings.append(f"{pokemon_name}: Stat '{stat}' is {stat_value} (over 255 is unusual)")
                
                # Calculate and warn about BST
                if all(stat in stats for stat in required_stats):
                    bst = sum(stats[stat] for stat in required_stats)
                    if bst < 180:
                        self.warnings.append(f"{pokemon_name}: Very low BST ({bst}) - weaker than Magikarp!")
                    elif bst > 720:
                        self.warnings.append(f"{pokemon_name}: Very high BST ({bst}) - stronger than Arceus!")
            
            # Check abilities
            if "abilities" in data:
                if not isinstance(data["abilities"], list):
                    self.errors.append(f"{pokemon_name}: abilities must be an array")
                elif len(data["abilities"]) == 0:
                    self.warnings.append(f"{pokemon_name}: Empty abilities array (will cause spawn issues)")
                else:
                    # Validate ability names
                    for ability in data["abilities"]:
                        ability_clean = ability.replace("h:", "").lower()
                        if ability_clean not in self.COMMON_ABILITIES:
                            self.warnings.append(f"{pokemon_name}: Unknown ability '{ability}' (might be a typo)")
            
            # Check moves list
            if "moves" in data:
                if isinstance(data["moves"], list):
                    move_count = len(data["moves"])
                    if move_count == 0:
                        self.warnings.append(f"{pokemon_name}: No moves defined (Pokemon won't know any moves!)")
                    elif move_count == 1 and data["moves"][0] == "1:tackle":
                        self.warnings.append(f"{pokemon_name}: Only has 'tackle' - this is likely a placeholder!")
                    
                    # Check move format and names
                    for move in data["moves"]:
                        if isinstance(move, str):
                            if ":" not in move:
                                self.errors.append(f"{pokemon_name}: Invalid move format '{move}' - must be 'level:movename'")
                            else:
                                level, move_name = move.split(":", 1)
                                
                                # Handle special prefixes (tm, egg, tutor)
                                if level.lower() in ["tm", "egg", "tutor"]:
                                    # These are valid non-numeric levels
                                    pass
                                else:
                                    # Validate level number
                                    try:
                                        level_num = int(level)
                                        if level_num < 1:
                                            self.warnings.append(f"{pokemon_name}: Move level {level_num} is less than 1")
                                        elif level_num > 100:
                                            self.warnings.append(f"{pokemon_name}: Move level {level_num} is over 100")
                                    except ValueError:
                                        self.errors.append(f"{pokemon_name}: Move level '{level}' is not a valid number or prefix (use 'tm', 'egg', 'tutor', or a number)")
                                
                                # Validate move name
                                move_name_clean = move_name.lower().strip().replace("_", "")
                                if move_name_clean not in self.COMMON_MOVES:
                                    # Check without underscores (some are formatted differently)
                                    self.warnings.append(f"{pokemon_name}: Unknown move '{move_name}' (might be a typo or modded move)")
            
            # Check catch rate
            if "catchRate" in data:
                catch_rate = data["catchRate"]
                if not isinstance(catch_rate, (int, float)):
                    self.errors.append(f"{pokemon_name}: catchRate must be a number")
                elif catch_rate < 3:
                    self.warnings.append(f"{pokemon_name}: catchRate {catch_rate} is very low (harder than legendaries!)")
                elif catch_rate > 255:
                    self.errors.append(f"{pokemon_name}: catchRate {catch_rate} exceeds maximum (255)")
            
            # Check height and weight
            if "height" in data:
                height = data["height"]
                if height <= 0:
                    self.warnings.append(f"{pokemon_name}: height {height} is zero or negative!")
                elif height < 1:
                    self.warnings.append(f"{pokemon_name}: height {height} is very small (under 0.1m)")
                elif height > 200:
                    self.warnings.append(f"{pokemon_name}: height {height} is enormous (over 20m!)")
            
            if "weight" in data:
                weight = data["weight"]
                if weight <= 0:
                    self.warnings.append(f"{pokemon_name}: weight {weight} is zero or negative!")
                elif weight > 10000:
                    self.warnings.append(f"{pokemon_name}: weight {weight} is extremely heavy (over 1000kg!)")
            
            # Check egg groups
            if "eggGroups" in data:
                if isinstance(data["eggGroups"], list):
                    for egg_group in data["eggGroups"]:
                        if egg_group.lower() not in self.VALID_EGG_GROUPS:
                            self.warnings.append(f"{pokemon_name}: Unknown egg group '{egg_group}'")
            
            return True
            
        except json.JSONDecodeError as e:
            self.errors.append(f"{pokemon_name}: Invalid JSON in species file: {e}")
            return False
        except Exception as e:
            self.errors.append(f"{pokemon_name}: Error reading species file: {e}")
            return False
    
    def check_model_file(self, pokemon_name: str) -> bool:
        """Check model .geo.json file"""
        model_file = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "models" / pokemon_name / f"{pokemon_name}.geo.json"
        
        # CRITICAL: Check for wrong filename format (underscores instead of dots)
        wrong_filename = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "models" / pokemon_name / f"{pokemon_name}_geo.json"
        if wrong_filename.exists():
            self.errors.append(f"{pokemon_name}: ‚ùå CRITICAL BUG! Model file uses UNDERSCORES: '{pokemon_name}_geo.json'")
            self.errors.append(f"  Must use DOTS: '{pokemon_name}.geo.json' (rename the file!)")
            return False
        
        if not model_file.exists():
            self.errors.append(f"{pokemon_name}: Missing model file: {model_file}")
            return False
        
        try:
            with open(model_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Check identifier
            if "minecraft:geometry" in data:
                geometries = data["minecraft:geometry"]
                if isinstance(geometries, list) and len(geometries) > 0:
                    identifier = geometries[0].get("description", {}).get("identifier", "")
                    expected = f"geometry.{pokemon_name}"
                    
                    # Check if identifier is completely wrong (different pokemon)
                    if identifier and not identifier.endswith(pokemon_name):
                        self.errors.append(f"{pokemon_name}: ‚ùå Model identifier '{identifier}' doesn't match filename!")
                        self.errors.append(f"  Expected: '{expected}'")
                    elif identifier != expected:
                        self.warnings.append(f"{pokemon_name}: Model identifier is '{identifier}', expected '{expected}'")
                    
                    # Extract bone names for later validation
                    bones = geometries[0].get("bones", [])
                    bone_names = [bone.get("name", "") for bone in bones if isinstance(bone, dict)]
                    # Store for cross-validation with animations
                    if not hasattr(self, 'model_bones'):
                        self.model_bones = {}
                    self.model_bones[pokemon_name] = bone_names
            
            # Check file size (warn if suspiciously small)
            file_size = model_file.stat().st_size
            if file_size < 100:
                self.warnings.append(f"{pokemon_name}: Model file is very small ({file_size} bytes) - might be empty!")
            
            return True
            
        except json.JSONDecodeError as e:
            self.errors.append(f"{pokemon_name}: Invalid JSON in model file: {e}")
            return False
        except Exception as e:
            self.errors.append(f"{pokemon_name}: Error reading model file: {e}")
            return False
    
    def check_animation_file(self, pokemon_name: str) -> bool:
        """Check animation .animation.json file"""
        anim_file = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "animations" / pokemon_name / f"{pokemon_name}.animation.json"
        
        # CRITICAL: Check for wrong filename format (underscores instead of dots)
        wrong_filename = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "animations" / pokemon_name / f"{pokemon_name}_animation.json"
        if wrong_filename.exists():
            self.errors.append(f"{pokemon_name}: ‚ùå CRITICAL BUG! Animation file uses UNDERSCORES: '{pokemon_name}_animation.json'")
            self.errors.append(f"  Must use DOTS: '{pokemon_name}.animation.json' (rename the file!)")
            return False
        
        if not anim_file.exists():
            self.errors.append(f"{pokemon_name}: Missing animation file: {anim_file}")
            return False
        
        try:
            with open(anim_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Check for animations
            if "animations" not in data:
                self.errors.append(f"{pokemon_name}: No 'animations' key in animation file")
                return False
            
            animations = data["animations"]
            
            # Check required animations
            for required_anim in self.REQUIRED_ANIMATIONS:
                anim_key = f"animation.{pokemon_name}.{required_anim}"
                if anim_key not in animations:
                    self.errors.append(f"{pokemon_name}: Missing required animation '{required_anim}'")
            
            # BONE MATCHING: Check if animation bones exist in model
            if hasattr(self, 'model_bones') and pokemon_name in self.model_bones:
                model_bone_names = self.model_bones[pokemon_name]
                
                for anim_name, anim_data in animations.items():
                    if isinstance(anim_data, dict) and "bones" in anim_data:
                        anim_bones = anim_data["bones"]
                        if isinstance(anim_bones, dict):
                            for bone_name in anim_bones.keys():
                                if bone_name not in model_bone_names:
                                    self.warnings.append(f"{pokemon_name}: Animation '{anim_name}' references bone '{bone_name}' that doesn't exist in model")
                                    self.warnings.append(f"  Model bones: {', '.join(model_bone_names)}")
            
            return True
            
        except json.JSONDecodeError as e:
            self.errors.append(f"{pokemon_name}: Invalid JSON in animation file: {e}")
            return False
        except Exception as e:
            self.errors.append(f"{pokemon_name}: Error reading animation file: {e}")
            return False
    
    def check_texture_files(self, pokemon_name: str) -> bool:
        """Check texture PNG files"""
        texture_dir = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "textures" / "pokemon" / pokemon_name
        
        # Check regular texture
        regular_texture = texture_dir / f"{pokemon_name}.png"
        if not regular_texture.exists():
            self.errors.append(f"{pokemon_name}: Missing regular texture: {regular_texture}")
            return False
        
        # Validate PNG format
        try:
            file_size = regular_texture.stat().st_size
            if file_size < 100:
                self.errors.append(f"{pokemon_name}: Texture file suspiciously small ({file_size} bytes) - may be corrupted")
            
            # Check if it's actually a PNG by reading header
            with open(regular_texture, 'rb') as f:
                header = f.read(8)
                if header != b'\x89PNG\r\n\x1a\n':
                    self.errors.append(f"{pokemon_name}: ‚ùå CRITICAL! '{pokemon_name}.png' is not a valid PNG file!")
                    self.errors.append(f"  File may be corrupted or wrong format")
        except Exception as e:
            self.warnings.append(f"{pokemon_name}: Could not validate texture format: {e}")
        
        # Check shiny texture
        shiny_texture = texture_dir / f"{pokemon_name}_shiny.png"
        if not shiny_texture.exists():
            self.warnings.append(f"{pokemon_name}: Missing shiny texture: {shiny_texture}")
        
        return True
    
    def check_poser_file(self, pokemon_name: str) -> bool:
        """Check poser JSON file"""
        poser_file = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "posers" / f"{pokemon_name}.json"
        
        if not poser_file.exists():
            self.errors.append(f"{pokemon_name}: Missing poser file: {poser_file}")
            return False
        
        try:
            with open(poser_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Check for poses
            if "poses" not in data:
                self.errors.append(f"{pokemon_name}: No 'poses' key in poser file")
                return False
            
            # CRITICAL HEAD FIELD BUG CHECK
            if "head" in data:
                head_bone = data["head"]
                if head_bone is None or head_bone == "null" or head_bone == "":
                    self.errors.append(f"{pokemon_name}: ‚ùå CRITICAL BUG! 'head' field is null/empty")
                    self.errors.append(f"  If no head bone, DELETE the 'head' field entirely (don't set to null!)")
                    self.errors.append(f"  This causes the 'practice dummy' bug!")
                else:
                    # Check if head bone actually exists in model
                    if hasattr(self, 'model_bones') and pokemon_name in self.model_bones:
                        model_bone_list = self.model_bones[pokemon_name]
                        if head_bone not in model_bone_list:
                            self.errors.append(f"{pokemon_name}: ‚ùå Head bone '{head_bone}' doesn't exist in model!")
                            self.errors.append(f"  Model bones are: {', '.join(model_bone_list)}")
            
            # Check for portrait scale (common issue)
            if "portraitScale" not in data:
                self.warnings.append(f"{pokemon_name}: Missing 'portraitScale' in poser (defaults to 1.0)")
            
            # Check for profile translation
            if "profileTranslation" not in data:
                self.warnings.append(f"{pokemon_name}: Missing 'profileTranslation' in poser")
            
            # Check each pose for animation references
            poses = data.get("poses", {})
            for pose_name, pose_data in poses.items():
                if isinstance(pose_data, dict):
                    # Check for animations array
                    if "animations" in pose_data:
                        anims = pose_data["animations"]
                        if isinstance(anims, list):
                            for anim in anims:
                                # Warn about "look" animation when head might be missing
                                if "look" in str(anim).lower() and "head" not in data:
                                    self.warnings.append(f"{pokemon_name}: Pose '{pose_name}' has 'look' animation but no head bone defined")
            
            return True
            
        except json.JSONDecodeError as e:
            self.errors.append(f"{pokemon_name}: Invalid JSON in poser file: {e}")
            return False
        except Exception as e:
            self.errors.append(f"{pokemon_name}: Error reading poser file: {e}")
            return False
    
    def check_resolver_file(self, pokemon_name: str) -> bool:
        """Check resolver JSON file"""
        # Correct location per wiki (no subfolder)
        resolver_file = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "resolvers" / f"0_{pokemon_name}_base.json"
        
        # Check if file exists
        if not resolver_file.exists():
            # Try with subfolder (backwards compatibility)
            resolver_file = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "resolvers" / pokemon_name / f"0_{pokemon_name}_base.json"
            
            if not resolver_file.exists():
                self.errors.append(f"{pokemon_name}: Missing resolver file (not found in either location)")
                return False
        
        # File exists, now validate it
        try:
            with open(resolver_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Check variations array
            if "variations" not in data:
                self.errors.append(f"{pokemon_name}: No 'variations' array in resolver")
                return False
            
            variations = data["variations"]
            if not isinstance(variations, list) or len(variations) == 0:
                self.errors.append(f"{pokemon_name}: Empty or invalid 'variations' in resolver")
                return False
            
            # Check first variation for model
            first_var = variations[0]
            if "model" in first_var:
                expected_model = f"cobblemon:{pokemon_name}.geo"
                if first_var["model"] != expected_model:
                    self.warnings.append(f"{pokemon_name}: Model reference is '{first_var['model']}', expected '{expected_model}'")
            else:
                self.errors.append(f"{pokemon_name}: No 'model' field in first variation")
            
            # Check for poser reference
            if "poser" not in first_var:
                self.warnings.append(f"{pokemon_name}: No 'poser' field in first variation")
            
            return True
            
        except json.JSONDecodeError as e:
            self.errors.append(f"{pokemon_name}: Invalid JSON in resolver file: {e}")
            return False
        except Exception as e:
            self.errors.append(f"{pokemon_name}: Error reading resolver file: {e}")
            return False
    
    def check_spawn_file(self, pokemon_name: str) -> bool:
        """Check spawn pool JSON file"""
        spawn_file = self.pack_path / "behavior_pack" / "data" / "cobblemon" / "spawn_pool_world" / f"{pokemon_name}.json"
        
        if not spawn_file.exists():
            self.warnings.append(f"{pokemon_name}: Missing spawn file (Pokemon won't spawn naturally)")
            return True  # Not a critical error
        
        try:
            with open(spawn_file, 'r') as f:
                data = json.load(f)
            
            # Check for spawns
            if "spawns" not in data:
                self.errors.append(f"{pokemon_name}: No 'spawns' array in spawn file")
                return False
            
            return True
            
        except json.JSONDecodeError as e:
            self.errors.append(f"{pokemon_name}: Invalid JSON in spawn file: {e}")
            return False
        except Exception as e:
            self.errors.append(f"{pokemon_name}: Error reading spawn file: {e}")
            return False
    
    def print_results(self):
        """Print all errors, warnings, and info"""
        print(f"\n{'='*70}")
        print("üìä RESULTS")
        print(f"{'='*70}\n")
        
        if self.errors:
            print(f"‚ùå ERRORS ({len(self.errors)}):")
            for error in self.errors:
                print(f"   ‚Ä¢ {error}")
            print()
        
        if self.warnings:
            print(f"‚ö†Ô∏è  WARNINGS ({len(self.warnings)}):")
            for warning in self.warnings:
                print(f"   ‚Ä¢ {warning}")
            print()
        
        if not self.errors and not self.warnings:
            print("‚úÖ NO ERRORS OR WARNINGS FOUND!")
            print("   Your pack looks good!\n")
        
        print(f"{'='*70}")
        print(f"Summary: {len(self.errors)} errors, {len(self.warnings)} warnings")
        print(f"{'='*70}\n")


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Cobblemon Pack Error Checker - Find issues in your pack",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('--pack-path', type=str, help='Path to pack directory')
    
    args = parser.parse_args()
    
    checker = CobblemonPackChecker(pack_path=args.pack_path)
    checker.check_all()


if __name__ == "__main__":
    main()
