#!/usr/bin/env python3
"""
Cobblemon Pack Error Checker (v2.0)
Validates all files in your Cobblemon pack for common errors
NOW WITH: Filename validation, bone matching, poser validation, and more!
"""

import json
import os
from pathlib import Path
from typing import Dict, List, Tuple


class CobblemonPackChecker:
    """Checks Cobblemon packs for errors"""
    
    VALID_TYPES = [
        "normal", "fire", "water", "electric", "grass", "ice", "fighting",
        "poison", "ground", "flying", "psychic", "bug", "rock", "ghost",
        "dragon", "dark", "steel", "fairy"
    ]
    
    REQUIRED_ANIMATIONS = [
        "ground_idle", "ground_walk", "battle_idle"
    ]
    
    OPTIONAL_ANIMATIONS = [
        "sleep", "faint", "cry", "air_idle", "air_fly", "water_idle", "water_swim"
    ]
    
    def __init__(self, pack_path: str = None):
        if pack_path is None:
            pack_path = str(Path.home() / "Downloads" / "Mod-ResourceAndBehavior-Packs")
        
        self.pack_path = Path(pack_path)
        self.errors = []
        self.warnings = []
        self.info = []
        
    def check_all(self):
        """Run all checks"""
        print(f"\n{'='*70}")
        print("üîç COBBLEMON PACK ERROR CHECKER v2.0")
        print(f"{'='*70}")
        print("‚ú® NEW in v2.0:")
        print("   ‚Ä¢ Filename validation (dots vs underscores)")
        print("   ‚Ä¢ Poser 'head' field null bug detection")
        print("   ‚Ä¢ Animation-Model bone matching")
        print("   ‚Ä¢ Case sensitivity checks")
        print("   ‚Ä¢ PNG format validation")
        print("   ‚Ä¢ Move list validation")
        print(f"{'='*70}\n")
        print(f"üìÅ Checking pack: {self.pack_path}\n")
        
        # Check pack structure
        self.check_pack_structure()
        
        # Find all Pokemon
        pokemon_list = self.find_all_pokemon()
        
        if not pokemon_list:
            self.errors.append("No Pok√©mon found in pack!")
            self.print_results()
            return
        
        print(f"Found {len(pokemon_list)} Pok√©mon to check...\n")
        
        # Check each Pokemon
        for pokemon_name in pokemon_list:
            self.check_pokemon(pokemon_name)
        
        # Print results
        self.print_results()
    
    def check_pack_structure(self):
        """Check basic pack structure"""
        print("üì¶ Checking pack structure...")
        
        # Check resource pack
        resource_pack = self.pack_path / "resource_pack"
        if not resource_pack.exists():
            self.errors.append("Missing resource_pack folder!")
        else:
            self.info.append("‚úì resource_pack folder exists")
        
        # Check behavior pack
        behavior_pack = self.pack_path / "behavior_pack"
        if not behavior_pack.exists():
            self.errors.append("Missing behavior_pack folder!")
        else:
            self.info.append("‚úì behavior_pack folder exists")
        
        print()
    
    def find_all_pokemon(self) -> List[str]:
        """Find all Pokemon in the pack"""
        pokemon = set()
        
        # Check species files
        species_dir = self.pack_path / "behavior_pack" / "data" / "cobblemon" / "species" / "custom"
        if species_dir.exists():
            for file in species_dir.glob("*.json"):
                pokemon.add(file.stem)
        
        return sorted(list(pokemon))
    
    def check_pokemon(self, pokemon_name: str):
        """Check all files for a specific Pokemon"""
        print(f"üîç Checking {pokemon_name.upper()}...")
        
        errors_found = False
        
        # CRITICAL: Check for case sensitivity issues
        if pokemon_name != pokemon_name.lower():
            self.errors.append(f"{pokemon_name}: ‚ùå CRITICAL! Pokemon name has uppercase letters")
            self.errors.append(f"  All Pokemon names must be lowercase: '{pokemon_name.lower()}'")
            errors_found = True
        
        # CRITICAL: Check for special characters
        import re
        if not re.match(r'^[a-z0-9_]+$', pokemon_name):
            self.errors.append(f"{pokemon_name}: ‚ùå CRITICAL! Pokemon name contains invalid characters")
            self.errors.append(f"  Only lowercase letters, numbers, and underscores allowed")
            errors_found = True
        
        # Check species file
        if not self.check_species_file(pokemon_name):
            errors_found = True
        
        # Check model file
        if not self.check_model_file(pokemon_name):
            errors_found = True
        
        # Check animation file
        if not self.check_animation_file(pokemon_name):
            errors_found = True
        
        # Check texture files
        if not self.check_texture_files(pokemon_name):
            errors_found = True
        
        # Check poser file
        if not self.check_poser_file(pokemon_name):
            errors_found = True
        
        # Check resolver file
        if not self.check_resolver_file(pokemon_name):
            errors_found = True
        
        # Check spawn file
        if not self.check_spawn_file(pokemon_name):
            errors_found = True
        
        if not errors_found:
            print(f"   ‚úÖ All checks passed!\n")
        else:
            print(f"   ‚ö†Ô∏è  Issues found (see below)\n")
    
    def check_species_file(self, pokemon_name: str) -> bool:
        """Check species JSON file"""
        species_file = self.pack_path / "behavior_pack" / "data" / "cobblemon" / "species" / "custom" / f"{pokemon_name}.json"
        
        if not species_file.exists():
            self.errors.append(f"{pokemon_name}: Missing species file: {species_file}")
            return False
        
        try:
            with open(species_file, 'r') as f:
                data = json.load(f)
            
            # Check required fields
            required_fields = ["name", "nationalPokedexNumber", "primaryType", "baseStats"]
            for field in required_fields:
                if field not in data:
                    self.errors.append(f"{pokemon_name}: Missing required field '{field}' in species file")
            
            # Check types
            if "primaryType" in data:
                ptype = data["primaryType"]
                if ptype is None:
                    self.errors.append(f"{pokemon_name}: primaryType is null!")
                else:
                    ptype = ptype.lower()
                    if ptype not in self.VALID_TYPES:
                        self.warnings.append(f"{pokemon_name}: Invalid primary type '{ptype}'")
            
            if "secondaryType" in data:
                stype = data["secondaryType"]
                if stype is None:
                    # Secondary type can be null (single-type Pokemon)
                    pass
                else:
                    stype = stype.lower()
                    if stype not in self.VALID_TYPES:
                        self.warnings.append(f"{pokemon_name}: Invalid secondary type '{stype}'")
            
            # Check base stats
            if "baseStats" in data:
                stats = data["baseStats"]
                required_stats = ["hp", "attack", "defence", "special_attack", "special_defence", "speed"]
                for stat in required_stats:
                    if stat not in stats:
                        self.errors.append(f"{pokemon_name}: Missing base stat '{stat}'")
            
            # Check abilities
            if "abilities" in data:
                if not isinstance(data["abilities"], list):
                    self.errors.append(f"{pokemon_name}: abilities must be an array")
                elif len(data["abilities"]) == 0:
                    self.warnings.append(f"{pokemon_name}: Empty abilities array (will cause spawn issues)")
                else:
                    # Abilities exist and not empty - good!
                    pass
            
            # Check moves list
            if "moves" in data:
                if isinstance(data["moves"], list):
                    move_count = len(data["moves"])
                    if move_count == 0:
                        self.warnings.append(f"{pokemon_name}: No moves defined (Pokemon won't know any moves!)")
                    elif move_count == 1 and data["moves"][0] == "1:tackle":
                        self.warnings.append(f"{pokemon_name}: Only has 'tackle' - this is likely a placeholder!")
                    
                    # Check move format
                    for move in data["moves"]:
                        if isinstance(move, str):
                            if ":" not in move:
                                self.errors.append(f"{pokemon_name}: Invalid move format '{move}' - must be 'level:movename'")
            
            return True
            
        except json.JSONDecodeError as e:
            self.errors.append(f"{pokemon_name}: Invalid JSON in species file: {e}")
            return False
        except Exception as e:
            self.errors.append(f"{pokemon_name}: Error reading species file: {e}")
            return False
    
    def check_model_file(self, pokemon_name: str) -> bool:
        """Check model .geo.json file"""
        model_file = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "models" / pokemon_name / f"{pokemon_name}.geo.json"
        
        # CRITICAL: Check for wrong filename format (underscores instead of dots)
        wrong_filename = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "models" / pokemon_name / f"{pokemon_name}_geo.json"
        if wrong_filename.exists():
            self.errors.append(f"{pokemon_name}: ‚ùå CRITICAL BUG! Model file uses UNDERSCORES: '{pokemon_name}_geo.json'")
            self.errors.append(f"  Must use DOTS: '{pokemon_name}.geo.json' (rename the file!)")
            return False
        
        if not model_file.exists():
            self.errors.append(f"{pokemon_name}: Missing model file: {model_file}")
            return False
        
        try:
            with open(model_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Check identifier
            if "minecraft:geometry" in data:
                geometries = data["minecraft:geometry"]
                if isinstance(geometries, list) and len(geometries) > 0:
                    identifier = geometries[0].get("description", {}).get("identifier", "")
                    expected = f"geometry.{pokemon_name}"
                    if identifier != expected:
                        self.warnings.append(f"{pokemon_name}: Model identifier is '{identifier}', expected '{expected}'")
                    
                    # Extract bone names for later validation
                    bones = geometries[0].get("bones", [])
                    bone_names = [bone.get("name", "") for bone in bones if isinstance(bone, dict)]
                    # Store for cross-validation with animations
                    if not hasattr(self, 'model_bones'):
                        self.model_bones = {}
                    self.model_bones[pokemon_name] = bone_names
            
            # Check file size (warn if suspiciously small)
            file_size = model_file.stat().st_size
            if file_size < 100:
                self.warnings.append(f"{pokemon_name}: Model file is very small ({file_size} bytes) - might be empty!")
            
            return True
            
        except json.JSONDecodeError as e:
            self.errors.append(f"{pokemon_name}: Invalid JSON in model file: {e}")
            return False
        except Exception as e:
            self.errors.append(f"{pokemon_name}: Error reading model file: {e}")
            return False
    
    def check_animation_file(self, pokemon_name: str) -> bool:
        """Check animation .animation.json file"""
        anim_file = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "animations" / pokemon_name / f"{pokemon_name}.animation.json"
        
        # CRITICAL: Check for wrong filename format (underscores instead of dots)
        wrong_filename = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "animations" / pokemon_name / f"{pokemon_name}_animation.json"
        if wrong_filename.exists():
            self.errors.append(f"{pokemon_name}: ‚ùå CRITICAL BUG! Animation file uses UNDERSCORES: '{pokemon_name}_animation.json'")
            self.errors.append(f"  Must use DOTS: '{pokemon_name}.animation.json' (rename the file!)")
            return False
        
        if not anim_file.exists():
            self.errors.append(f"{pokemon_name}: Missing animation file: {anim_file}")
            return False
        
        try:
            with open(anim_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Check for animations
            if "animations" not in data:
                self.errors.append(f"{pokemon_name}: No 'animations' key in animation file")
                return False
            
            animations = data["animations"]
            
            # Check required animations
            for required_anim in self.REQUIRED_ANIMATIONS:
                anim_key = f"animation.{pokemon_name}.{required_anim}"
                if anim_key not in animations:
                    self.errors.append(f"{pokemon_name}: Missing required animation '{required_anim}'")
            
            # BONE MATCHING: Check if animation bones exist in model
            if hasattr(self, 'model_bones') and pokemon_name in self.model_bones:
                model_bone_names = self.model_bones[pokemon_name]
                
                for anim_name, anim_data in animations.items():
                    if isinstance(anim_data, dict) and "bones" in anim_data:
                        anim_bones = anim_data["bones"]
                        if isinstance(anim_bones, dict):
                            for bone_name in anim_bones.keys():
                                if bone_name not in model_bone_names:
                                    self.warnings.append(f"{pokemon_name}: Animation '{anim_name}' references bone '{bone_name}' that doesn't exist in model")
                                    self.warnings.append(f"  Model bones: {', '.join(model_bone_names)}")
            
            return True
            
        except json.JSONDecodeError as e:
            self.errors.append(f"{pokemon_name}: Invalid JSON in animation file: {e}")
            return False
        except Exception as e:
            self.errors.append(f"{pokemon_name}: Error reading animation file: {e}")
            return False
    
    def check_texture_files(self, pokemon_name: str) -> bool:
        """Check texture PNG files"""
        texture_dir = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "textures" / "pokemon" / pokemon_name
        
        # Check regular texture
        regular_texture = texture_dir / f"{pokemon_name}.png"
        if not regular_texture.exists():
            self.errors.append(f"{pokemon_name}: Missing regular texture: {regular_texture}")
            return False
        
        # Validate PNG format
        try:
            file_size = regular_texture.stat().st_size
            if file_size < 100:
                self.errors.append(f"{pokemon_name}: Texture file suspiciously small ({file_size} bytes) - may be corrupted")
            
            # Check if it's actually a PNG by reading header
            with open(regular_texture, 'rb') as f:
                header = f.read(8)
                if header != b'\x89PNG\r\n\x1a\n':
                    self.errors.append(f"{pokemon_name}: ‚ùå CRITICAL! '{pokemon_name}.png' is not a valid PNG file!")
                    self.errors.append(f"  File may be corrupted or wrong format")
        except Exception as e:
            self.warnings.append(f"{pokemon_name}: Could not validate texture format: {e}")
        
        # Check shiny texture
        shiny_texture = texture_dir / f"{pokemon_name}_shiny.png"
        if not shiny_texture.exists():
            self.warnings.append(f"{pokemon_name}: Missing shiny texture: {shiny_texture}")
        
        return True
    
    def check_poser_file(self, pokemon_name: str) -> bool:
        """Check poser JSON file"""
        poser_file = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "posers" / f"{pokemon_name}.json"
        
        if not poser_file.exists():
            self.errors.append(f"{pokemon_name}: Missing poser file: {poser_file}")
            return False
        
        try:
            with open(poser_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Check for poses
            if "poses" not in data:
                self.errors.append(f"{pokemon_name}: No 'poses' key in poser file")
                return False
            
            # CRITICAL HEAD FIELD BUG CHECK
            if "head" in data:
                if data["head"] is None or data["head"] == "null" or data["head"] == "":
                    self.errors.append(f"{pokemon_name}: ‚ùå CRITICAL BUG! 'head' field is null/empty")
                    self.errors.append(f"  If no head bone, DELETE the 'head' field entirely (don't set to null!)")
                    self.errors.append(f"  This causes the 'practice dummy' bug!")
            
            # Check for portrait scale (common issue)
            if "portraitScale" not in data:
                self.warnings.append(f"{pokemon_name}: Missing 'portraitScale' in poser (defaults to 1.0)")
            
            # Check for profile translation
            if "profileTranslation" not in data:
                self.warnings.append(f"{pokemon_name}: Missing 'profileTranslation' in poser")
            
            # Check each pose for animation references
            poses = data.get("poses", {})
            for pose_name, pose_data in poses.items():
                if isinstance(pose_data, dict):
                    # Check for animations array
                    if "animations" in pose_data:
                        anims = pose_data["animations"]
                        if isinstance(anims, list):
                            for anim in anims:
                                # Warn about "look" animation when head might be missing
                                if "look" in str(anim).lower() and "head" not in data:
                                    self.warnings.append(f"{pokemon_name}: Pose '{pose_name}' has 'look' animation but no head bone defined")
            
            return True
            
        except json.JSONDecodeError as e:
            self.errors.append(f"{pokemon_name}: Invalid JSON in poser file: {e}")
            return False
        except Exception as e:
            self.errors.append(f"{pokemon_name}: Error reading poser file: {e}")
            return False
    
    def check_resolver_file(self, pokemon_name: str) -> bool:
        """Check resolver JSON file"""
        # Correct location per wiki (no subfolder)
        resolver_file = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "resolvers" / f"0_{pokemon_name}_base.json"
        
        # Check if file exists
        if not resolver_file.exists():
            # Try with subfolder (backwards compatibility)
            resolver_file = self.pack_path / "resource_pack" / "assets" / "cobblemon" / "bedrock" / "pokemon" / "resolvers" / pokemon_name / f"0_{pokemon_name}_base.json"
            
            if not resolver_file.exists():
                self.errors.append(f"{pokemon_name}: Missing resolver file (not found in either location)")
                return False
        
        # File exists, now validate it
        try:
            with open(resolver_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Check variations array
            if "variations" not in data:
                self.errors.append(f"{pokemon_name}: No 'variations' array in resolver")
                return False
            
            variations = data["variations"]
            if not isinstance(variations, list) or len(variations) == 0:
                self.errors.append(f"{pokemon_name}: Empty or invalid 'variations' in resolver")
                return False
            
            # Check first variation for model
            first_var = variations[0]
            if "model" in first_var:
                expected_model = f"cobblemon:{pokemon_name}.geo"
                if first_var["model"] != expected_model:
                    self.warnings.append(f"{pokemon_name}: Model reference is '{first_var['model']}', expected '{expected_model}'")
            else:
                self.errors.append(f"{pokemon_name}: No 'model' field in first variation")
            
            # Check for poser reference
            if "poser" not in first_var:
                self.warnings.append(f"{pokemon_name}: No 'poser' field in first variation")
            
            return True
            
        except json.JSONDecodeError as e:
            self.errors.append(f"{pokemon_name}: Invalid JSON in resolver file: {e}")
            return False
        except Exception as e:
            self.errors.append(f"{pokemon_name}: Error reading resolver file: {e}")
            return False
    
    def check_spawn_file(self, pokemon_name: str) -> bool:
        """Check spawn pool JSON file"""
        spawn_file = self.pack_path / "behavior_pack" / "data" / "cobblemon" / "spawn_pool_world" / f"{pokemon_name}.json"
        
        if not spawn_file.exists():
            self.warnings.append(f"{pokemon_name}: Missing spawn file (Pokemon won't spawn naturally)")
            return True  # Not a critical error
        
        try:
            with open(spawn_file, 'r') as f:
                data = json.load(f)
            
            # Check for spawns
            if "spawns" not in data:
                self.errors.append(f"{pokemon_name}: No 'spawns' array in spawn file")
                return False
            
            return True
            
        except json.JSONDecodeError as e:
            self.errors.append(f"{pokemon_name}: Invalid JSON in spawn file: {e}")
            return False
        except Exception as e:
            self.errors.append(f"{pokemon_name}: Error reading spawn file: {e}")
            return False
    
    def print_results(self):
        """Print all errors, warnings, and info"""
        print(f"\n{'='*70}")
        print("üìä RESULTS")
        print(f"{'='*70}\n")
        
        if self.errors:
            print(f"‚ùå ERRORS ({len(self.errors)}):")
            for error in self.errors:
                print(f"   ‚Ä¢ {error}")
            print()
        
        if self.warnings:
            print(f"‚ö†Ô∏è  WARNINGS ({len(self.warnings)}):")
            for warning in self.warnings:
                print(f"   ‚Ä¢ {warning}")
            print()
        
        if not self.errors and not self.warnings:
            print("‚úÖ NO ERRORS OR WARNINGS FOUND!")
            print("   Your pack looks good!\n")
        
        print(f"{'='*70}")
        print(f"Summary: {len(self.errors)} errors, {len(self.warnings)} warnings")
        print(f"{'='*70}\n")


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Cobblemon Pack Error Checker - Find issues in your pack",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('--pack-path', type=str, help='Path to pack directory')
    
    args = parser.parse_args()
    
    checker = CobblemonPackChecker(pack_path=args.pack_path)
    checker.check_all()


if __name__ == "__main__":
    main()
